#include <iostream>
#include <cstring>

using namespace std;

class vect {
private:
    int dim;        // Размерность вектора
    double* b;      // Указатель на массив элементов
    int num;        // Номер объекта
    static int count; // Счетчик объектов

public:
    // Конструктор по умолчанию
    vect() : dim(0), b(nullptr), num(++count) {
        cout << "Создан вектор #" << num << " по умолчанию" << endl;
    }

    // Конструктор с заданной размерностью
    vect(int dimension) : dim(dimension), num(++count) {
        b = new double[dim];
        for (int i = 0; i < dim; i++) b[i] = 0.0;
        cout << "Создан вектор #" << num << " размерности " << dim << endl;
    }

    // Конструктор копирования
    vect(const vect& v) : dim(v.dim), num(++count) {
        b = new double[dim];
        for (int i = 0; i < dim; i++) b[i] = v.b[i];
        cout << "Создан вектор #" << num << " копированием из вектора #" << v.num << endl;
    }

    // Деструктор
    ~vect() {
        delete[] b;
        cout << "Уничтожен вектор #" << num << endl;
    }

    // Оператор присваивания
    vect& operator=(const vect& v) {
        cout << "Присваивание: вектор #" << num << " = вектору #" << v.num << endl;
        if (this != &v) {
            delete[] b;
            dim = v.dim;
            b = new double[dim];
            for (int i = 0; i < dim; i++) b[i] = v.b[i];
        }
        return *this;
    }

    // Оператор сложения векторов
    vect operator+(const vect& v) const {
        cout << "Сложение: вектор #" << num << " + вектор #" << v.num << endl;
        if (dim != v.dim) throw "Размерности векторов не совпадают!";
        vect result(dim);
        for (int i = 0; i < dim; i++) result.b[i] = b[i] + v.b[i];
        return result;
    }

    // Оператор вычитания векторов
    vect operator-(const vect& v) const {
        cout << "Вычитание: вектор #" << num << " - вектор #" << v.num << endl;
        if (dim != v.dim) throw "Размерности векторов не совпадают!";
        vect result(dim);
        for (int i = 0; i < dim; i++) result.b[i] = b[i] - v.b[i];
        return result;
    }

    // Оператор унарного минуса
    vect operator-() const {
        cout << "Унарный минус: -вектор #" << num << endl;
        vect result(dim);
        for (int i = 0; i < dim; i++) result.b[i] = -b[i];
        return result;
    }

    // Оператор умножения вектора на скаляр
    friend vect operator*(double k, const vect& v) {
        cout << "Умножение: " << k << " * вектор #" << v.num << endl;
        vect result(v.dim);
        for (int i = 0; i < v.dim; i++) result.b[i] = k * v.b[i];
        return result;
    }

    // Оператор скалярного произведения
    double operator*(const vect& v) const {
        cout << "Скалярное произведение: вектор #" << num << " * вектор #" << v.num << endl;
        if (dim != v.dim) throw "Размерности векторов не совпадают!";
        double result = 0.0;
        for (int i = 0; i < dim; i++) result += b[i] * v.b[i];
        return result;
    }

    // Метод для установки значений
    void set(int index, double value) {
        if (index < 0 || index >= dim) throw "Индекс вне диапазона!";
        b[index] = value;
    }

    // Метод для получения значений
    double get(int index) const {
        if (index < 0 || index >= dim) throw "Индекс вне диапазона!";
        return b[index];
    }

    // Метод для вывода вектора
    void print() const {
        cout << "Вектор #" << num << " [";
        for (int i = 0; i < dim; i++) {
            cout << b[i];
            if (i < dim - 1) cout << ", ";
        }
        cout << "]" << endl;
    }
};

int vect::count = 0;

class matr {
private:
    int dim;        // Размерность матрицы (квадратная)
    double* a;      // Указатель на массив элементов (одномерное представление)
    int num;        // Номер объекта
    static int count; // Счетчик объектов

public:
    // Конструктор по умолчанию
    matr() : dim(0), a(nullptr), num(++count) {
        cout << "Создана матрица #" << num << " по умолчанию" << endl;
    }

    // Конструктор с заданной размерностью
    matr(int dimension) : dim(dimension), num(++count) {
        a = new double[dim * dim];
        for (int i = 0; i < dim * dim; i++) a[i] = 0.0;
        cout << "Создана матрица #" << num << " размерности " << dim << "x" << dim << endl;
    }

    // Конструктор копирования
    matr(const matr& m) : dim(m.dim), num(++count) {
        a = new double[dim * dim];
        for (int i = 0; i < dim * dim; i++) a[i] = m.a[i];
        cout << "Создана матрица #" << num << " копированием из матрицы #" << m.num << endl;
    }

    // Деструктор
    ~matr() {
        delete[] a;
        cout << "Уничтожена матрица #" << num << endl;
    }

    // Оператор присваивания
    matr& operator=(const matr& m) {
        cout << "Присваивание: матрица #" << num << " = матрице #" << m.num << endl;
        if (this != &m) {
            delete[] a;
            dim = m.dim;
            a = new double[dim * dim];
            for (int i = 0; i < dim * dim; i++) a[i] = m.a[i];
        }
        return *this;
    }

    // Оператор сложения матриц
    matr operator+(const matr& m) const {
        cout << "Сложение: матрица #" << num << " + матрица #" << m.num << endl;
        if (dim != m.dim) throw "Размерности матриц не совпадают!";
        matr result(dim);
        for (int i = 0; i < dim * dim; i++) result.a[i] = a[i] + m.a[i];
        return result;
    }

    // Оператор вычитания матриц
    matr operator-(const matr& m) const {
        cout << "Вычитание: матрица #" << num << " - матрица #" << m.num << endl;
        if (dim != m.dim) throw "Размерности матриц не совпадают!";
        matr result(dim);
        for (int i = 0; i < dim * dim; i++) result.a[i] = a[i] - m.a[i];
        return result;
    }

    // Оператор унарного минуса
    matr operator-() const {
        cout << "Унарный минус: -матрица #" << num << endl;
        matr result(dim);
        for (int i = 0; i < dim * dim; i++) result.a[i] = -a[i];
        return result;
    }

    // Оператор умножения матрицы на скаляр
    friend matr operator*(double k, const matr& m) {
        cout << "Умножение: " << k << " * матрица #" << m.num << endl;
        matr result(m.dim);
        for (int i = 0; i < m.dim * m.dim; i++) result.a[i] = k * m.a[i];
        return result;
    }

    // Оператор умножения матриц
    matr operator*(const matr& m) const {
        cout << "Умножение: матрица #" << num << " * матрица #" << m.num << endl;
        if (dim != m.dim) throw "Размерности матриц не совпадают!";
        matr result(dim);
        for (int i = 0; i < dim; i++) {
            for (int j = 0; j < dim; j++) {
                double sum = 0.0;
                for (int k = 0; k < dim; k++) {
                    sum += a[i * dim + k] * m.a[k * dim + j];
                }
                result.a[i * dim + j] = sum;
            }
        }
        return result;
    }

    // Оператор умножения матрицы на вектор
    vect operator*(const vect& v) const {
        cout << "Умножение: матрица #" << num << " * вектор #" << v.num << endl;
        if (dim != v.dim) throw "Размерности не совпадают!";
        vect result(dim);
        for (int i = 0; i < dim; i++) {
            double sum = 0.0;
            for (int j = 0; j < dim; j++) {
                sum += a[i * dim + j] * v.get(j);
            }
            result.set(i, sum);
        }
        return result;
    }

    // Метод для установки значений
    void set(int row, int col, double value) {
        if (row < 0 || row >= dim || col < 0 || col >= dim) throw "Индекс вне диапазона!";
        a[row * dim + col] = value;
    }

    // Метод для получения значений
    double get(int row, int col) const {
        if (row < 0 || row >= dim || col < 0 || col >= dim) throw "Индекс вне диапазона!";
        return a[row * dim + col];
    }

    // Метод для вывода матрицы
    void print() const {
        cout << "Матрица #" << num << " [" << endl;
        for (int i = 0; i < dim; i++) {
            cout << "  [";
            for (int j = 0; j < dim; j++) {
                cout << a[i * dim + j];
                if (j < dim - 1) cout << ", ";
            }
            cout << "]" << endl;
        }
        cout << "]" << endl;
    }
};

int matr::count = 0;

int main() {
    try {
        // Демонстрация работы с векторами
        cout << "\n=== Работа с векторами ===" << endl;
        vect v1(3), v2(3), v3(3);
        
        // Установка значений
        v1.set(0, 1.0); v1.set(1, 2.0); v1.set(2, 3.0);
        v2.set(0, 4.0); v2.set(1, 5.0); v2.set(2, 6.0);
        
        // Вывод векторов
        v1.print();
        v2.print();
        
        // Операции с векторами
        v3 = v1 + v2;
        v3.print();
        
        v3 = v1 - v2;
        v3.print();
        
        v3 = -v1;
        v3.print();
        
        v3 = 2.5 * v1;
        v3.print();
        
        double dot = v1 * v2;
        cout << "Скалярное произведение: " << dot << endl;
        
        // Демонстрация работы с матрицами
        cout << "\n=== Работа с матрицами ===" << endl;
        matr m1(2), m2(2), m3(2);
        
        // Установка значений
        m1.set(0, 0, 1.0); m1.set(0, 1, 2.0);
        m1.set(1, 0, 3.0); m1.set(1, 1, 4.0);
        
        m2.set(0, 0, 5.0); m2.set(0, 1, 6.0);
        m2.set(1, 0, 7.0); m2.set(1, 1, 8.0);
        
        // Вывод матриц
        m1.print();
        m2.print();
        
        // Операции с матрицами
        m3 = m1 + m2;
        m3.print();
        
        m3 = m1 - m2;
        m3.print();
        
        m3 = -m1;
        m3.print();
        
        m3 = 3.0 * m1;
        m3.print();
        
        m3 = m1 * m2;
        m3.print();
        
        // Умножение матрицы на вектор
        vect v4(2);
        v4.set(0, 1.0); v4.set(1, 2.0);
        
        vect v5 = m1 * v4;
        v5.print();
        
    } catch (const char* msg) {
        cerr << "Ошибка: " << msg << endl;
    }
    
    return 0;
}
